# Homework 11.2

## Задача 1: API Gateway

Решений существует довольно много, поэтому выбрал несколько рандомных, которые чаще всего выдаются при гуглении. Честно говоря, не совсем понял про требования. Они довольно базовые и все рассмотренные шлюзы поддерживают такой функционал:

|         | Маршрутизация запросов | Аутентификация | Терминация HTTPS |
|---------|------------------------|----------------|------------------|
| Tyk     |            +           |       +        |        +         |
| Amazon  |            +           |       +        |        +         |
| Apigee  |            +           |       +        |        +         |
| Goku    |            +           |       +        |        +         |
| Azure   |            +           |       +        |        +         |

Для выбора явно недостаточно вводных данных. Amazon, Apigee и Azure, пожалуй, следует использовать, если наша инфраструктура расположена в облаках AWS, Google, Azure. Tyk и Goku опенсорсные, что несёт в себе свои плюсы и минусы - бесплатно, но нет поддержки и т.д.

## Задача 2: Брокер сообщений

И с этим заданием у меня снова возникли проблемы. Четыре из шести критериев довольно простые и поддерживаются всеми. Оставшиеся два довольно субъективные и их нельзя оценить однозначно. Вот так выглядит анализ трех вариантов:

|          | Кластеризация | Хранение | Скорость | Форматы | Права | Простота |
|----------|---------------|----------|----------|---------|-------|----------|
| RabbitMQ | +             | +        | ?        | +       | +     | ?        |
| Kafka    | +             | +        | ?        | +       | +     | ?        |
| ActiveMQ | +             | +        | ?        | +       | +     | ?        |

Например, RabbitMQ использует push модель доставки, значит логика реализуется на стороне брокера. А в Kafka pull метод и логика настраивается на стороне клиента. Непонятно, что здесь считать проще, а что сложнее.

Со скоростью тоже всё не так однозначно. Вроде RabbitMQ быстрее, но опять же так как он сам всем управляет, то расходуется больше ресурсов и при огромных нагрузках он будет наоборот терять в производительности.

По сути, в задании требуется выбрать лучшее решение в вакууме. Без каких-либо реальных вводных данных, которые можно было бы использовать для анализа.
