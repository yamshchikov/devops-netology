# Homework 3.2
1. CD - это shell builtin.  

   Это логично, так как без неё в shell было бы практически невозможно работать. Наверное, почти все действия можно
   выполнить, просто указав абсолютный путь, но это неудобно.
   
   Думаю, её без проблем можно было бы установить отдельным пакетом сразу после установки системы, но зачем, если ей 
   пользуется 100% пользователей.
2. `grep -c <some_string> <some_file>`
3. systemd
4. `ls ~/non-existent-folder/ 2>/dev/pts/1`
5. Во входном файле 20 строк, содержащих line01, line02 и т.д.
    ```
    michael@michael-pc:~$ grep 8 <file_in >file_out
    michael@michael-pc:~$ cat file_out
    line08
    line18
    ```
6. Да, `ls ~/non-existent-folder/ 2>/dev/tty3` отправляет вывод ошибки в эмулятор терминала и я его могу там наблюдать. 
   Но у меня возник странный вопрос - почему все экземпляры pts хранятся внутри каталога /dev/pts под разными цифрами, 
   а экземпляры эмулятора лежат в корне /dev? Просто так исторически сложилось или есть причина?
7. Первая команда создает поток с дескриптором 5 и перенаправляет его туда же, куда и первый.  
   Вторая команда отправляет вывод на 5-й поток, который указывает в dev/pts/0 и поэтому он отображается в терминале.
8. Вывод первого файла остается в терминале, а обе ошибки уходят через pipe:
    ```
    michael@michael-pc:~$ cat 1 2 3
    line1
    line2
    line3
    cat: 2: No such file or directory
    cat: 3: No such file or directory
    michael@michael-pc:~$  bash 5>/dev/pts/0
    michael@michael-pc:~$ cat 1 2 3 2>&1 1>&5 | grep 3 >4
    line1
    line2
    line3
    michael@michael-pc:~$ cat 4
    cat: 3: No such file or directory
    ```
9. Файл содержит переменные оркужения. Их еще можно получить командой `env`
10. cmdline - содержит командную строку процесса  
    exe - содержит ссылку на адрес исполняемой команды. Введя /proc/\[pid\]/exe можно запустить копию процесса.
11. sse 4.2
12. При такой отправке команды, она исполняется не внутри терминала, поэтому нет tty. Можно форсировать исполнение
    команды в псевдо терминале с помощью опции -t `ssh -t localhost tty`
13. В целом идея понятна и проста, но я так и не смог заставить эту программу работать.  
    В текущей сессии создаю sleep 1h и отправляю в бэкграунд.  
    Создаю новый screen и пытаюсь забрать туда sleep `reptyr 1520`  
    После этого всё зависает и ни на что не реагирует. Переключаюсь из screen обратно на основую сессию.  
    Вижу, что процесс reptyr висит в screen, видимо завис. Sleep остался в текущем сеансе (и ещё почему-то раздвоился)
    ```
    ├─screen(1522)───bash(1523)───reptyr(1531)
    ├─sshd(650)───sshd(1442)───sshd(1480)───bash(1481)─┬─pstree(1535)
                                                       └─sleep(1520)───sleep(1532)    
    ```
    Причем нигде не нашел про это инфы. Пишут просто заберите процесс и всё. Буду ещё разбираться с работой этой
    приложухи, но сейчас сил уже нет, и так часа 3 потратил) Может подскажете, в чем проблема.
14. tee по сути делает то же самое, что и простое перенаправление через >. Читает из stdin и отправляет в stdout или 
    файл. Но так как это отдельное приложение, мы можем запустить его от root'a с помощью sudo и поэтому оно сможет
    перезаписать /root/new_file.